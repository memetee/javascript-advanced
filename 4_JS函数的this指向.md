## 为什么需要this？

在常见的编程语言中，几乎都有this这个关键字（Objective-C中使用的是self），但是JavaScript中的this和常见的面向对象语 言中的this不太一样：

- 常见面向对象的编程语言中，比如Java、C++、Swift、Dart等等一系列语言中，this通常只会出现在类的方法中。
- 也就是你需要有一个类，类中的方法（特别是实例方法）中，this代表的是当前调用对象。但是JavaScript中的this更加灵活，无论是它出现的位置还是它代表的含义。

我们来看一下编写一个obj的对象，有this和没有this的区别

![image-20220705075612835](.\4_JS函数的this指向\image-20220705075612835.png)

直接用obj也是没有问题的，从某些角度来说，开发中没有this也是有解决方案的

但是如果上面的obj编程info了呢？那么obj.name就需要改成info.name,

所以，如果没有this，会让我们编写代码非常的不方便

![image-20220705075635550](.\4_JS函数的this指向\image-20220705075635550.png)



## this指向什么呢？

我们先说一个最简单的，this在全局作用于下指向什么？

浏览器：window(globalObject)

- 这个问题非常容易回答，在浏览器中测试就是指向window

![image-20220705075713152](.\4_JS函数的this指向\image-20220705075713152.png)



但是，开发中很少直接在全局作用于下去使用this，通常都是在函数中使用。

- 所有的函数在被调用时，都会创建一个执行上下文：
- 这个上下文中记录着函数的调用栈、AO对象等；
- this也是其中的一条记录；

node:{}(空对象)

![image-20220705075749507](.\4_JS函数的this指向\image-20220705075749507.png)



node中每一个js文件都是一个模块，首先会进行加载，然后编辑，然后他会放到一个函数中，并且调用这个函数，但是在调用这个函数的时候，他会改变this执行，通过apply的方式来调用，并且给这个apply传入一个空对象，所以，node中全局的this指向的是{}



node中为什么是{}

![image-20220705075812233](.\4_JS函数的this指向\image-20220705075812233.png)





## this到底指向什么呢？

this在内存中的哪个位置呢

globalObject

![image-20220705075840604](.\4_JS函数的this指向\image-20220705075840604.png)

我们先来看一个让人困惑的问题：

- 定义一个函数，我们采用三种不同的方式对它进行调用，它产生了三种不同的结果

![image-20220705075858476](.\4_JS函数的this指向\image-20220705075858476.png)



这个的案例可以给我们什么样的启示呢？

- 函数在调用时，JavaScript会默认给this绑定一个值；
- this的绑定和定义的位置（编写的位置）没有关系；
- this的绑定和调用方式以及调用的位置有关系；
- this是在运行时被绑定的；

那么this到底是怎么样的绑定规则呢？一起来学习一下吧

- 绑定一：默认绑定；
- 绑定二：隐式绑定；
- 绑定三：显示绑定；
- 绑定四：new绑定；





## 规则一：默认绑定

什么情况下使用默认绑定呢？独立函数调用.

- 独立的函数调用我们可以理解成函数没有被绑定到某个对象上进行调用；

我们通过几个案例来看一下，常见的默认绑定

![image-20220705080049774](.\4_JS函数的this指向\image-20220705080049774.png)

![image-20220705080101980](.\4_JS函数的this指向\image-20220705080101980.png)

![image-20220705080106904](.\4_JS函数的this指向\image-20220705080106904.png)

![image-20220705080111256](.\4_JS函数的this指向\image-20220705080111256.png)

闭包中的this

![image-20220705080128235](.\4_JS函数的this指向\image-20220705080128235.png)

它们的打印都是window





## 规则二：隐式绑定

另外一种比较常见的调用方式是通过某个对象进行调用的：

- 也就是它的调用位置中，是通过某个对象发起的函数调用。

我们通过几个案例来看一下，常见的默认绑定

![image-20220712074153951](.\4_JS函数的this指向\image-20220712074153951.png)

![image-20220712074158990](.\4_JS函数的this指向\image-20220712074158990.png)

![image-20220712074204462](.\4_JS函数的this指向\image-20220712074204462.png)





## 规则三：显示绑定

隐式绑定有一个前提条件：

- 必须在调用的对象内部有一个对函数的引用（比如一个属性）；
- 如果没有这样的引用，在进行调用时，会报找不到该函数的错误；
- 正是通过这个引用，间接的将this绑定到了这个对象上；

如果我们不希望在 对象内部 包含这个函数的引用，同时又希望在这个对象上进行强制调用，该怎么做呢？

- JavaScript所有的函数都可以使用call和apply方法（这个和Prototype有关）
  - 它们两个的区别这里不再展开；
  - 其实非常简单，第一个参数是相同的，后面的参数，apply为数组，call为参数列表；
- 这两个函数的第一个参数都要求是一个对象，这个对象的作用是什么呢？就是给this准备的。
- 在调用这个函数时，会将this绑定到这个传入的对象上。

因为上面的过程，我们明确的绑定了this指向的对象，所以称之为 显示绑定。





## call、apply、bind

通过call或者apply绑定this对象

- 显示绑定后，this就会明确的指向绑定的对象

![image-20220712074411688](.\4_JS函数的this指向\image-20220712074411688.png)



call和apply有什么区别

![image-20220712074424937](.\4_JS函数的this指向\image-20220712074424937.png)

传参的形式是不一样的

- 如果我们希望一个函数总是显示的绑定到一个对象上，可以怎么做呢？

![image-20220712074442323](.\4_JS函数的this指向\image-20220712074442323.png)

![image-20220712074446970](.\4_JS函数的this指向\image-20220712074446970.png)





## 内置函数的绑定思考

有些时候，我们会调用一些JavaScript的内置函数，或者一些第三方库中的内置函数。

- 这些内置函数会要求我们传入另外一个函数；
- 我们自己并不会显示的调用这些函数，而且JavaScript内部或者第三方库内部会帮助我们执行；
- 这些函数中的this又是如何绑定的呢？

setTimeout、数组的forEach、div的点击

![image-20220712074541535](.\4_JS函数的this指向\image-20220712074541535.png)

在实现setTimeout的时候，它的内部是独立函数调用， 所以它是window

![image-20220712074552964](.\4_JS函数的this指向\image-20220712074552964.png)



隐式绑定，相当于这样调用

![image-20220712074605127](.\4_JS函数的this指向\image-20220712074605127.png)



addEventListener

![image-20220712074618827](.\4_JS函数的this指向\image-20220712074618827.png)

它可以监听多个

内部应该是把他们放到一个数组里面

然后依次执行内部的this

应该是通过修改this执行 fn.call(boxDiv)





数组.forEach/map/filter/find

![image-20220712074657730](.\4_JS函数的this指向\image-20220712074657730.png)

![image-20220712074703059](.\4_JS函数的this指向\image-20220712074703059.png)



显示绑定this,这里是把他绑定为obj

![image-20220712074714200](.\4_JS函数的this指向\image-20220712074714200.png)





## new绑定

JavaScript中的函数可以当做一个类的构造函数来使用，也就是使用new关键字。

使用new关键字来调用函数是，会执行如下的操作：

- 创建一个全新的对象；
- 这个新对象会被执行prototype连接；
- 这个新对象会绑定到函数调用的this上（this的绑定在这个步骤完成）；
- 如果函数没有返回其他对象，表达式会返回这个新对象；

![image-20220712074806653](.\4_JS函数的this指向\image-20220712074806653.png)





## 规则优先级

学习了四条规则，接下来开发中我们只需要去查找函数的调用应用了哪条规则即可，但是如果一个函数调用位置应用了多 条规则，优先级谁更高呢？

- 默认规则的优先级最低
  - 毫无疑问，默认规则的优先级是最低的，因为存在其他规则时，就会通过其他规则的方式来绑定this
- 显示绑定优先级高于隐式绑定

![image-20220712074853602](.\4_JS函数的this指向\image-20220712074853602.png)

call/apply/是一样的

bind的优先级比较

![image-20220712074910052](.\4_JS函数的this指向\image-20220712074910052.png)

![image-20220712074914515](.\4_JS函数的this指向\image-20220712074914515.png)

- new绑定优先级高于隐式绑定

![image-20220712074931438](.\4_JS函数的this指向\image-20220712074931438.png)



- new绑定优先级高于bind
  - new绑定和call、apply是不允许同时使用的，所以不存在谁的优先级更高
  - new绑定可以和bind一起使用，new绑定优先级更高

![image-20220712075001153](.\4_JS函数的this指向\image-20220712075001153.png)



## 总结

![image-20220712075011193](.\4_JS函数的this指向\image-20220712075011193.png)





## this规则之外 – 忽略显示绑定

- 我们讲到的规则已经足以应付平时的开发，但是总有一些语法，超出了我们的规则之外。（神话故事和动漫中总是 有类似这样的人物）
- 如果在显示绑定中，我们传入一个null或者undefined，那么这个显示绑定会被忽略，使用默认规则：

![image-20220712075043495](.\4_JS函数的this指向\image-20220712075043495.png)





## this规则之外 - 间接函数引用

另外一种情况，创建一个函数的 间接引用，这种情况使用默认绑定规则。

- 赋值(obj2.foo = obj1.foo)的结果是foo函数
- foo函数被直接调用，那么是默认绑定；

![image-20220712075119395](.\4_JS函数的this指向\image-20220712075119395.png)

![image-20220712075124210](.\4_JS函数的this指向\image-20220712075124210.png)

![image-20220712075129199](.\4_JS函数的this指向\image-20220712075129199.png)





## 箭头函数 arrow function

箭头函数是ES6之后增加的一种编写函数的方法，并且它比函数表达式要更加简洁：

- 箭头函数不会绑定this、arguments属性；
- 箭头函数不能作为构造函数来使用（不能和new一起来使用，会抛出错误）；

箭头函数如何编写呢？

- (): 函数的参数
- {}: 函数的执行体

![image-20220712075219439](.\4_JS函数的this指向\image-20220712075219439.png)

![image-20220712075223921](.\4_JS函数的this指向\image-20220712075223921.png)

![image-20220712075229420](.\4_JS函数的this指向\image-20220712075229420.png)

![image-20220712075234506](.\4_JS函数的this指向\image-20220712075234506.png)

![image-20220712075239800](.\4_JS函数的this指向\image-20220712075239800.png)







## this规则之外 – ES6箭头函数

在ES6中新增一个非常好用的函数类型：箭头函数

- 这里不再具体介绍箭头函数的用法，可以自行学习。

箭头函数不使用this的四种标准规则（也就是不绑定this），而是根据外层作用域来决定this。

![image-20220712075316311](.\4_JS函数的this指向\image-20220712075316311.png)



我们来看一个模拟网络请求的案例：

- 这里我使用setTimeout来模拟网络请求，请求到数据后如何可以存放到data中呢？
- 我们需要拿到obj对象，设置data；
- 但是直接拿到的this是window，我们需要在外层定义：var _this = this
- 在setTimeout的回调函数中使用_this就代表了obj对象

![image-20220712075348075](.\4_JS函数的this指向\image-20220712075348075.png)





## ES6箭头函数（arrow function）this

之前的代码在ES6之前是我们最常用的方式，从ES6开始，我们会使用箭头函数：

- 为什么在setTimeout的回调函数中可以直接使用this呢？
- 因为箭头函数并不绑定this对象，那么this引用就会从上层作用于中找到对应的this

![image-20220712075423979](.\4_JS函数的this指向\image-20220712075423979.png)

![image-20220712075427715](.\4_JS函数的this指向\image-20220712075427715.png)

箭头函数不绑定this,那么去上层作用域找，就找了了getData，getData函数中的this指向的是obj，所以箭头函数中的this指向了obj,可以给data赋值了

![image-20220712075439307](.\4_JS函数的this指向\image-20220712075439307.png)

思考：如果getData也是一个箭头函数，那么setTimeout中的回调函数中的this指向谁呢？





## 面试题一：

![image-20220712075504967](.\4_JS函数的this指向\image-20220712075504967.png)

![image-20220712075510635](.\4_JS函数的this指向\image-20220712075510635.png)





## 面试题二：

![image-20220712075525015](.\4_JS函数的this指向\image-20220712075525015.png)

![image-20220712075529325](.\4_JS函数的this指向\image-20220712075529325.png)





## 面试题三：

![image-20220712075543362](.\4_JS函数的this指向\image-20220712075543362.png)

![image-20220712075548733](.\4_JS函数的this指向\image-20220712075548733.png)





## 面试题四：

![image-20220712075605605](.\4_JS函数的this指向\image-20220712075605605.png)

![image-20220712075610510](.\4_JS函数的this指向\image-20220712075610510.png)

![image-20220712075615550](.\4_JS函数的this指向\image-20220712075615550.png)