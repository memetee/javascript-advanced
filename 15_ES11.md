## ES11-BigInt

在早期的JavaScript中，我们不能正确的表示过大的数字：
- 大于MAX_SAFE_INTEGER的数值，表示的可能是不正确的。

```js
const maxInt = Number.MAX_SAFE_INTEGER
console.log(maxInt) // 9007199254740991

// 大于MAX_SAFE_INTEGER值的一些数值，无法正确的表示
console.log(maxInt + 1) // 9007199254740992
console.log(maxInt + 2) // 9007199254740992
```



那么ES11中，引入了新的数据类型BigInt，用于表示大的整数：
- BitInt的表示方法是在数值的后面加上n

```js
const bigInt = 9007199254740991n
console.log(bigInt + 1n)  // 9007199254740992n
console.log(bigInt + 2n)  // 9007199254740993n

//这种是做了隐式转换
console.log(4 + 'abc') // 10abc

//但是bigInt类型加上数字类型是不会做隐式转换的(报错)
const bigInt = 9007199254740991n
console.log(bigInt + 4)  // TypeError: Cannot mix BigInt and other types, use explicit conversions

// 所以需要加上n，转成大数字类型
const bigInt = 9007199254740991n
console.log(bigInt + 4n)  // 9007199254740995n

// 或者这样处理
const bigInt = 9007199254740991n
console.log(bigInt + BigInt(4))  // 9007199254740995n

// 把大数字转成number类型, 但是转换过后的类型，有可能是不正确的
const bigInt = 9007199254740999n
console.log(Number(bigInt)) // 9007199254741000
```



## ES11-Nullish Coalescing Operator（空值合并操作）

ES11，Nullish Coalescing Operator增加了空值合并操作符：

```JS
const foo = ''
const result1 = foo || '默认值'
const result2 = foo ?? '默认值'
console.log(result1) // 默认值
console.log(result2) // ''
```

如果foo有值就用foo 如果foo是null或者是undefined 那么就用默认值

但是 || 是有一个弊端的，如果foo是空字符串的话，或者foo是0的话，它也会用默认值，但是这个时候可能我想要的就是一个空字符串，或者就是0，但是你给我一个默认值，肯定是不正确的

空值合并运算符可以解决这种弊端，只有foo在null或者undefined的时候，才会执行后面的默认值，否则返回的就是foo的值



## ES11-Optional Chaining（可选链）

可选链也是ES11中新增一个特性，主要作用是让我们的代码在进行null和undefined判断时更加清晰和简洁：

```js
const obj = {
  friend: {
    girlFriend: {
      name: 'lucy'
    }
  }
}

// 传统的判断
if (obj.friend && obj.friend.girlFriend) {
  console.log(obj.friend.girlFriend.name)
}

// 可选链来判断
console.log(obj.friend?.girlFriend?.name)
// 如果不存在friend或者girlFriend的话，打印结果为undefined
```

上面的可选链，如果obj.frient没有girlFriend的话，就返回undefined,主要解决的是一个报错，就是我们从undefined中取出数据是会报错的，而且会影响下面的代码运行，可选链的作用就能避免了这个问题



## ES11-Global This

在之前我们希望获取JavaScript环境的全局对象，不同的环境获取的方式是不一样的
- 比如在浏览器中可以通过this、window来获取；
- 比如在Node中我们需要通过global来获取；

那么在ES11中对获取全局对象进行了统一的规范：globalThis

```js
console.log(this)	// 浏览器上才能用
console.log(window)	// 浏览器上才能用

console.log(global)	// node中才能用

console.log(globalThis) // 都可以用
```

那么如果同一份代码想在node环境下，又想在浏览器环境下，同时拿到全局对象，在以前需要去判断window是否为undefined，但是现在可以用**globalThis**，在不同环境下指向的都是全局对象



## ES11-for...in标准化

在ES11之前，虽然很多浏览器支持for...in来遍历对象类型，但是并没有被ECMA标准化。

在ES11中，对其进行了标准化，for...in是用于遍历对象的key的：

```js
const obj = {
  name: 'wts',
  age: 18,
  height: 1.88
}
for(const key in obj) {
  console.log(key)
}
```



## ES11-其他知识点

Dynamic Import（动态导入）：后续ES Module模块化中讲解。

Promise.allSettled：后续讲Promise的时候讲解。

import meta：后续ES Module模块化中讲解。

