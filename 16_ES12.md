## ES12 - FinalizationRegistry

FinalizationRegistry 对象可以让你在对象被垃圾回收时请求一个回调。
- FinalizationRegistry 提供了这样的一种方法：当一个在注册表中注册的对象被回收时，请求在某个时间点上调用一个清理回调。（清理回调有时被称为 finalizer ）;
- 你可以通过调用register方法，注册任何你想要清理回调的对象，传入该对象和所含的值;

- finalizationRegistry是一个类
- register是注册的意思
- node在执行代码的时候，会开启一个进程，但是等代码执行到最后一行之后，node会把这个进程关掉，所以，可能存在回调没有打印的情况
- 浏览器不会这样，可以正常打印上面的内容

```javascript
const finalRegistry = new FinalizationRegistry(() => {
  console.log('注册在finalizationRegistry的对象，某一个销毁了')
})
let obj = {name: 'wts'};
finalRegistry.register(obj);  //注册这个对象
obj = null

let obj1 = {name: 'wts111'};
finalRegistry.register(obj1); // 每销毁一次，上面监听的就会打印一次
obj1 = null;

// 那么怎么区分是哪个对象的打印呢
// 在注册的时候可以传递一个参数
let obj2 = {name: 'wts'};
let obj3 = {name: 'wts'};
const finalRegistry1 = new FinalizationRegistry((value) => {
  console.log('注册在finalizationRegistry的对象，某一个销毁了', value)
})
finalRegistry1.register(obj2, 'obj')
finalRegistry1.register(obj3, 'obj1')
obj2 = null;
obj3 = null;

/**
 * 当把obj置为null的时候，就会打印   注册在finalizationRegistry的对象，某一个销毁了
 * 也就是说当这个对象被销毁的时候，这个打印就会出现
 * 但是销毁机制GC，它是一种算法，不是说，只要obj被销毁了，他就会立即打印，而是等一个随机
 * 的时间，GC才会来把他回收掉，这个时候才会打印
 */

// 注册在finalizationRegistry的对象，某一个销毁了
// 注册在finalizationRegistry的对象，某一个销毁了
// 注册在finalizationRegistry的对象，某一个销毁了 obj1
// 注册在finalizationRegistry的对象，某一个销毁了 obj
```

- obj1和obj就是传递的参数



## ES12 - WeakRefs

如果我们默认将一个对象赋值给另外一个引用，那么这个引用是一个强引用：

首先这种情况，obj指向的对象不会被销毁，因为他被info指向着，这是个强引用指向

```js
const finalRegistry = new FinalizationRegistry((value) => {
  console.log("注册在finalRegistry的对象, 某一个被销毁", value)
})

let obj = { name: "why" }
let info = obj

finalRegistry.register(obj, "obj")

obj = null
```

如果我们希望是一个弱引用的话，可以使用WeakRef；

```js
const finalRegistry = new FinalizationRegistry((value) => {
  console.log("注册在finalRegistry的对象, 某一个被销毁", value)
})

let obj = { name: "why" }
let info = new WeakRef(obj)	// 这里的info就变成了弱引用

finalRegistry.register(obj, "obj")

obj = null
// 这个时候obj被置空以后，就会打印注册在finalRegistry的对象, 某一个被销毁，因为只有弱引用的话，会被GC回收
```

```js
let obj = { name: "wts" }
let info = new WeakRef(obj)	// 这里的info就变成了弱引用
console.log(info.deref().name) // wts	访问ref对象

obj = null
// 5秒钟之后弱引用已经被GC回收了，所以这里取不到name就报错了
setTimeout(() => {
    console.log(info.deref().name)	// cannot read properties of undefined(reading 'name')
}, 5000)

// 如果要解决这个报错可以这样
setTimeout(() => {
	console.log(info.deref()?.name)	// undefined
  console.log(info.deref() && info.deref().name) // undefined
}, 5000)
```

> WeakRef的原型上有一个属性叫deref
>
> WeakRef.prototype.deref
>
> 如果原对象没有销毁, 那么可以获取到原对象,如果原对象已经销毁, 那么获取到的是undefined



## ES12 - logical assignment operators（逻辑赋值运算）

逻辑或赋值运算  ||=

```js
let message = undefined;
// 或者message = ''
// 我们需要在message有值的时候使用Message, 如果message没有值就用默认值，我们以前可能会这样做
message = message || "default value"；
// 使用逻辑或赋值运算以后可以这样做
message ||= 'default value'	// 它的效果是一样的
// 它和 += 类似的
```

逻辑与赋值运算 &&=
```js
let info = {
  name: 'wts',
	foo: function () {
    console.log('foo')
  }
}
info && info.foo()

// 这两种都是可以的
info = info && info.name
info &&= info.name
```

逻辑空赋值运算 ??=

```js
let message = "";
// 这里的message是一个空字符串，会当成一个false，会把default value赋值给message
// message = 0,也会把message当成false
message ||= 'default value'

//当message = ''的时候 这个表达式的值是 '', 当message = 0的时候，这个表达式的值是0，当message = undefined/null的时候这个表达式的结果的default value
// 也就是这个表达式只判断undefined和null
message ?? = 'default value'
```





## ES12其他知识点

Numeric Separator：讲过了；

```js
// 数字分隔符
1_010_101_001
```

String.replaceAll：字符串替换；

```js
let str = 'abcdabcdabcd'
console.log(str.replaceAll('a', 'a1'))  // a1bcda1bcda1bcd
```



